# This file was auto-generated by Fern. It is not intended for manual modification.

from __future__ import annotations

import json
import logging
import random
import threading
import time
import typing
from types import TracebackType

from ..core.client_wrapper import SyncClientWrapper
from .errors import RefreshFailureError

if typing.TYPE_CHECKING:
    from .client import OnFailureCallback, OnSuccessCallback

# Set up a logger for this module
logger = logging.getLogger(__name__)


class CredentialDetails(typing.TypedDict):
    """Defines the shape of the mock credential data."""
    expires_at: float
    refreshed: bool

MockCredentialStore = typing.Dict[str, CredentialDetails]

# Mock data for development purposes. In a real scenario, this would involve API calls.
MOCK_CREDENTIALS_STORE: MockCredentialStore = {
    "token_ok_1": {"expires_at": time.time() + 86400 * 45, "refreshed": False},
    "token_expiring_soon": {"expires_at": time.time() + 86400 * 15, "refreshed": False},
    "token_retry_failure": {"expires_at": time.time() + 86400 * 10, "refreshed": False},
    "token_immediate_failure": {"expires_at": time.time() + 86400 * 5, "refreshed": False},
}


class JsonLogFormatter(logging.Formatter):
    """Custom formatter to output logs in JSON format."""
    def format(self, record: logging.LogRecord)-> str:
        log_record: typing.Dict[str, typing.Any] = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "name": record.name,
        }
        if isinstance(record.msg, dict):
            log_record.update(typing.cast(typing.Dict[str, typing.Any], record.msg))
        else:
            log_record["message"] = record.getMessage()
        
        if record.exc_info:
            log_record['exc_info'] = self.formatException(record.exc_info)
        
        return json.dumps(log_record)

class AssuranceAgent:
    """
    The core implementation of the Merge Assurance background agent.
    Manages the lifecycle of monitoring and remediating credentials.
    """

    def __init__(
        self,
        *,
        client_wrapper: SyncClientWrapper,
        on_success: typing.Optional[OnSuccessCallback] = None,
        on_failure: typing.Optional[OnFailureCallback] = None,
        check_interval_seconds: int,
        expiry_threshold_days: int
    ) -> None:
        self._client_wrapper = client_wrapper
        self._on_success = on_success
        self._on_failure = on_failure
        self._check_interval_seconds = check_interval_seconds
        self._expiry_threshold_seconds = expiry_threshold_days * 86400

        self._timer: typing.Optional[threading.Timer] = None
        self._stop_event = threading.Event()
        self._running = False
        self._processing_lock = threading.Lock()

    def is_running(self) -> bool:
        return self._running

    def start(self) -> None:
        """Starts the agent's monitoring loop in a background thread."""
        log_data = {
            "message": "Assurance Agent starting.",
            "component": "AssuranceAgent",
            "check_interval_seconds": self._check_interval_seconds
        }
        logger.info(log_data)
        self._running = True
        self._schedule_next_run()

    def _schedule_next_run(self) -> None:
        """Schedules the next execution of the check cycle."""
        if not self._stop_event.is_set():
            self._timer = threading.Timer(self._check_interval_seconds, self._run_check_cycle)
            self._timer.daemon = True
            self._timer.start()

    def _run_check_cycle(self) -> None:
        """The main workhorse method, executed periodically by the timer."""
        if self._stop_event.is_set() or not self._processing_lock.acquire(blocking=False):
            if not self._stop_event.is_set():
                logger.warning({"message": "Skipping check cycle, previous cycle still running.", "component": "AssuranceAgent"})
            return
        
        try:
            logger.info({"message": "Assurance Agent running check cycle.", "component": "AssuranceAgent"})
            self._check_and_remediate_credentials()
        except Exception as e:
            logger.error({"message": "Unhandled exception in check cycle.", "error": str(e), "component": "AssuranceAgent"})
        finally:
            self._processing_lock.release()
            if not self._stop_event.is_set():
                self._schedule_next_run()
        
    def _check_and_remediate_credentials(self) -> None:
        """Fetches credentials and triggers remediation for those nearing expiry"""
        now = time.time()
        for token, details in MOCK_CREDENTIALS_STORE.items():
            if details.get("refreshed", False):
                continue

            expires_at = details.get("expires_at", 0)
            time_to_expiry = expires_at - now

            if 0 < time_to_expiry <= self._expiry_threshold_seconds:
                log_data = {
                    "message": "Expiring token detected. Attempting refresh.",
                    "component": "AssuranceAgent",
                    "account_token": token,
                    "expires_in_days": round(time_to_expiry / 86400, 1),
                }
                logger.warning(log_data)
                threading.Thread(target=self._attempt_refresh_with_retries, args=(token,)).start()

    def _attempt_refresh_with_retries(self, account_token: str) -> None:
        """
        Attempts to refresh a token with exponential backoff and jitter.
        """
        max_retries = 5
        base_delay_seconds = 0.1  # Reduced for testing
        last_exception: typing.Optional[Exception] = None

        for attempt in range(max_retries):
            try:
                self._mock_api_refresh_call(account_token)
                
                logger.info({"message": "Successfully refreshed token.", "component": "AssuranceAgent", "account_token": account_token})
                if self._on_success:
                    try:
                        self._on_success(account_token)
                    except Exception as cb_exc:
                        logger.error({"message": "on_success callback failed.", "error": str(cb_exc), "component": "AssuranceAgent"})
                return
            
            except Exception as e:
                if "non-retryable" in str(e):
                    logger.error({"message": "Non-retryable error during refresh.", "component": "AssuranceAgent", "account_token": account_token, "error": str(e)})
                    MOCK_CREDENTIALS_STORE[account_token]["refreshed"] = True
                    break

                log_data = {
                    "message": "Refresh attempt failed. Retrying.",
                    "component": "AssuranceAgent",
                    "account_token": account_token,
                    "attempt": attempt + 1,
                    "max_attempts": max_retries,
                    "error": str(e),
                }
                logger.warning(log_data)
                
                if attempt < max_retries - 1:
                    delay = (base_delay_seconds * (2 ** attempt)) + random.uniform(0, 0.1)
                    time.sleep(delay)
        
        # If the loop finishes, it means all retries were exhausted or a non-retryable error occurred
        final_error = RefreshFailureError(f"Failed to refresh token '{account_token}' after {max_retries} attempts.", last_exception)
        logger.error({"message": "All refresh attempts failed for token.", "component": "AssuranceAgent", "account_token": account_token})
        if self._on_failure:
            try:
                self._on_failure(account_token, final_error)
            except Exception as cb_exc:
                logger.error({"message": "on_failure callback failed.", "error": str(cb_exc), "component": "AssuranceAgent"})
        
        # Mark as refreshed so we don't try again.
        MOCK_CREDENTIALS_STORE[account_token]["refreshed"] = True

    def _mock_api_refresh_call(self, account_token: str) -> None:
        """A mock function to simulate the API call and its potential failures."""
        if account_token == "token_expiring_soon":
            MOCK_CREDENTIALS_STORE[account_token]["expires_at"] = time.time() + 86400 * 60
            MOCK_CREDENTIALS_STORE[account_token]["refreshed"] = True
            return
        elif account_token == "token_retry_failure":
            raise ConnectionError("Mock API server is unavailable (503 Service Unavailable)")
        elif account_token == "token_immediate_failure":
            raise ValueError("Mock API reports invalid refresh token (401 Unauthorized) - non-retryable")

    def shutdown(self, wait: bool = True, timeout_seconds: typing.Optional[float] = None) -> None:
        """Signals the background agent to shut down gracefully."""
        logger.info({"message": "Shutdown signal received.", "component": "AssuranceAgent"})
        self._stop_event.set()
        if self._timer:
            self._timer.cancel()
        # Wait for the processing lock to be released for a clean shutdown
        if wait:
            if not self._processing_lock.acquire(timeout=timeout_seconds or 5.0):
                logger.error({"message": "Agent shutdown timed out waiting for processing to complete.", "component": "AssuranceAgent"})
        self._running = False
        logger.info({"message": "Assurance Agent stopped.", "component": "AssuranceAgent"})

    def __enter__(self) -> "AssuranceAgent":
        return self

    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[TracebackType],
    )-> None:
        self.shutdown()