# This file was auto-generated by Fern. It is not intended for manual modification.

from __future__ import annotations

import json
import logging
import random
import threading
import time
import typing
from types import TracebackType

import httpx

from ..core.api_error import ApiError
from ..core.client_wrapper import SyncClientWrapper
from .errors import RefreshFailureError

if typing.TYPE_CHECKING:
    from .client import OnFailureCallback, OnSuccessCallback

# Set up a logger for this module
logger = logging.getLogger(__name__)


class JsonLogFormatter(logging.Formatter):
    """Custom formatter to output logs in JSON format."""

    def format(self, record: logging.LogRecord) -> str:
        log_record: typing.Dict[str, typing.Any] = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "name": record.name,
        }
        if isinstance(record.msg, dict):
            log_record.update(typing.cast(typing.Dict[str, typing.Any], record.msg))
        else:
            log_record["message"] = record.getMessage()

        if record.exc_info:
            log_record["exc_info"] = self.formatException(record.exc_info)

        return json.dumps(log_record)


class AssuranceAgent:
    """
    The core implementation of the Merge Assurance background agent.
    Manages the lifecycle of monitoring and remediating credentials.
    """

    def __init__(
        self,
        *,
        client_wrapper: SyncClientWrapper,
        on_success: typing.Optional[OnSuccessCallback] = None,
        on_failure: typing.Optional[OnFailureCallback] = None,
        check_interval_seconds: int,
        expiry_threshold_days: int,
        # The base_url is injected for E2E testing to point to the mock server.
        # In production, the client_wrapper's default base_url would be used.
        base_url: typing.Optional[str] = None,
    ) -> None:
        self._client_wrapper = client_wrapper
        self._on_success = on_success
        self._on_failure = on_failure
        self._check_interval_seconds = check_interval_seconds
        self._expiry_threshold_seconds = expiry_threshold_days * 86400
        self._base_url = base_url or self._client_wrapper.get_base_url()

        self._timer: typing.Optional[threading.Timer] = None
        self._stop_event = threading.Event()
        self._running = False
        self._processing_lock = threading.Lock()
        # Add a set to track tokens that have definitively failed.
        self._failed_tokens: typing.Set[str] = set()

    def is_running(self) -> bool:
        return self._running

    def start(self) -> None:
        """Starts the agent's monitoring loop in a background thread."""
        log_data = {
            "message": "Assurance Agent starting.",
            "component": "AssuranceAgent",
            "check_interval_seconds": self._check_interval_seconds,
        }
        logger.info(log_data)
        self._running = True
        self._schedule_next_run()

    def _schedule_next_run(self) -> None:
        """Schedules the next execution of the check cycle."""
        if not self._stop_event.is_set():
            self._timer = threading.Timer(self._check_interval_seconds, self._run_check_cycle)
            self._timer.daemon = True
            self._timer.start()

    def _run_check_cycle(self) -> None:
        """The main workhorse method, executed periodically by the timer."""
        if self._stop_event.is_set() or not self._processing_lock.acquire(blocking=False):
            if not self._stop_event.is_set():
                logger.warning({"message": "Skipping check cycle, previous cycle still running.", "component": "AssuranceAgent"})
            return

        try:
            logger.info({"message": "Assurance Agent running check cycle.", "component": "AssuranceAgent"})
            self._check_and_remediate_credentials()
        except Exception as e:
            logger.error({"message": "Unhandled exception in check cycle.", "error": str(e), "component": "AssuranceAgent"})
        finally:
            self._processing_lock.release()
            if not self._stop_event.is_set():
                self._schedule_next_run()

    def _check_and_remediate_credentials(self) -> None:
        """Fetches credentials from the (mock) API and triggers remediation."""
        try:
            # In a real implementation, this endpoint would provide credential expiry info.
            # For this POC, we hit our mock server.
            response = self._client_wrapper.httpx_client.request(
                "/api/v1/credentials", method="GET", base_url=self._base_url
            )
            response.raise_for_status()
            credentials = typing.cast(typing.Dict[str, typing.Any], response.json())
        except ApiError as e:
            logger.error({"message": "Failed to fetch credentials for checking.", "error": str(e), "component": "AssuranceAgent"})
            return

        now = time.time()
        for token, details in credentials.items():
            if details.get("refreshed", False):
                continue

            # Skip tokens that we've already determined are unrecoverable.
            if token in self._failed_tokens:
                logger.debug({"message": "Skipping token marked as failed.", "component": "AssuranceAgent", "account_token": token})
                continue

            expires_at = details.get("expires_at", 0)
            time_to_expiry = expires_at - now

            if 0 < time_to_expiry <= self._expiry_threshold_seconds:
                log_data = {
                    "message": "Expiring token detected. Attempting refresh.",
                    "component": "AssuranceAgent",
                    "account_token": token,
                    "expires_in_days": round(time_to_expiry / 86400, 1),
                }
                logger.warning(log_data)
                threading.Thread(target=self._attempt_refresh_with_retries, args=(token,)).start()

    def _attempt_refresh_with_retries(self, account_token: str) -> None:
        """Attempts to refresh a token with exponential backoff and jitter via a real API call."""
        max_retries = 5
        base_delay_seconds = 5
        last_exception: typing.Optional[Exception] = None

        for attempt in range(max_retries):
            try:
                response = self._client_wrapper.httpx_client.request(
                    "/api/v1/refresh-token",
                    method="POST",
                    json={"account_token": account_token},
                    base_url=self._base_url,
                )
                response.raise_for_status()
                logger.info({"message": "Successfully refreshed token.", "component": "AssuranceAgent", "account_token": account_token})
                if self._on_success:
                    self._on_success(account_token)
                return

            except httpx.HTTPStatusError as e:
                last_exception = e
                # Non-retryable errors (e.g., 4xx client errors) should fail immediately.
                if 400 <= e.response.status_code < 500:
                    logger.error({"message": "Non-retryable API error during refresh.", "component": "AssuranceAgent", "account_token": account_token, "status_code": e.response.status_code, "error": str(e.response.text)})
                    break
                # Retryable errors (e.g., 5xx server errors, timeouts)
                log_data = {
                    "message": "Refresh attempt failed with retryable error. Retrying.",
                    "component": "AssuranceAgent",
                    "account_token": account_token,
                    "attempt": attempt + 1,
                    "max_attempts": max_retries,
                    "error": str(e),
                }
                logger.warning(log_data)
            except Exception as e:
                # Catch other potential exceptions like network issues
                last_exception = e
                log_data = {
                    "message": "Refresh attempt failed with unexpected error. Retrying.",
                    "component": "AssuranceAgent",
                    "account_token": account_token,
                    "attempt": attempt + 1,
                    "max_attempts": max_retries,
                    "error": str(e),
                }
                logger.warning(log_data)

            if attempt < max_retries - 1:
                delay = (base_delay_seconds * (2**attempt)) + random.uniform(0, 0.1)
                time.sleep(delay)

        final_error = RefreshFailureError(f"Failed to refresh token '{account_token}' after exhausting retries.", last_exception)
        logger.error({"message": "All refresh attempts failed for token.", "component": "AssuranceAgent", "account_token": account_token})
        # Add the token to our set of failed tokens so we don't retry it on the next cycle.
        self._failed_tokens.add(account_token)
        if self._on_failure:
            self._on_failure(account_token, final_error)

    def shutdown(self, wait: bool = True, timeout_seconds: typing.Optional[float] = None) -> None:
        """Signals the background agent to shut down gracefully."""
        logger.info({"message": "Shutdown signal received.", "component": "AssuranceAgent"})
        self._stop_event.set()
        if self._timer:
            self._timer.cancel()
        if wait:
            if not self._processing_lock.acquire(timeout=timeout_seconds or 5.0):
                logger.error({"message": "Agent shutdown timed out waiting for processing to complete.", "component": "AssuranceAgent"})
        self._running = False
        logger.info({"message": "Assurance Agent stopped.", "component": "AssuranceAgent"})

    def __enter__(self) -> "AssuranceAgent":
        return self

    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[TracebackType],
    ) -> None:
        self.shutdown()